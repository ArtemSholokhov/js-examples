"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestItFormatter = void 0;
const cucumber_1 = require("@cucumber/cucumber");
const testit_api_client_1 = require("testit-api-client");
const storage_1 = require("./storage");
const utils_1 = require("./utils");
class TestItFormatter extends cucumber_1.Formatter {
    constructor(options, config) {
        super(options);
        this.storage = new storage_1.Storage();
        this.attachmentsQueue = [];
        this.client = new testit_api_client_1.Client(config);
        options.eventBroadcaster.on('envelope', (envelope) => {
            if (envelope.meta) {
                return this.onMeta(envelope.meta);
            }
            if (envelope.gherkinDocument) {
                return this.onGherkinDocument(envelope.gherkinDocument);
            }
            if (envelope.pickle) {
                if (this.resolvedAutotests !== undefined) {
                    if (this.resolvedAutotests.length > 0) {
                        const tags = (0, utils_1.parseTags)(envelope.pickle.tags);
                        for (const externalId of this.resolvedAutotests) {
                            if (externalId === tags.externalId) {
                                return this.onPickle(envelope.pickle);
                            }
                        }
                    }
                    envelope.pickle = undefined;
                }
                else {
                    return this.onPickle(envelope.pickle);
                }
            }
            if (envelope.testCase) {
                if (this.testRunId === undefined && this.storage.isResolvedTestCase(envelope.testCase)) {
                    this.createTestRun();
                }
                return this.onTestCase(envelope.testCase);
            }
            if (envelope.testRunStarted) {
                return this.onTestRunStarted(envelope.testRunStarted);
            }
            if (envelope.testCaseStarted) {
                return this.onTestCaseStarted(envelope.testCaseStarted);
            }
            if (envelope.testStepStarted) {
                return this.testStepStarted(envelope.testStepStarted);
            }
            if (envelope.testStepFinished) {
                return this.onTestStepFinished(envelope.testStepFinished);
            }
            if (envelope.testCaseFinished) {
                return this.testCaseFinished(envelope.testCaseFinished);
            }
            if (envelope.testRunFinished) {
                return this.onTestRunFinished(envelope.testRunFinished);
            }
        });
        options.supportCodeLibrary.World.prototype.addMessage =
            this.addMessage.bind(this);
        options.supportCodeLibrary.World.prototype.addLinks =
            this.addLinks.bind(this);
        options.supportCodeLibrary.World.prototype.addAttachments =
            this.addAttachments.bind(this);
    }
    onMeta(_meta) {
        const { testRunId, configurationId } = this.client.getConfig();
        if (testRunId !== undefined) {
            this.testRunId = Promise.resolve(testRunId);
            const responce = this.client.getTestRun(testRunId);
            this.resolvedAutotests = (0, utils_1.parsedAutotests)(responce.testResults, configurationId);
        }
    }
    onGherkinDocument(document) {
        this.storage.saveGherkinDocument(document);
    }
    onPickle(pickle) {
        this.storage.savePickle(pickle);
    }
    onTestRunStarted(_testRunStarted) {
        if (this.testRunId !== undefined) {
            this.testRunStarted = this.testRunId.then((id) => this.client.startTestRun(id));
        }
    }
    onTestCase(testCase) {
        this.storage.saveTestCase(testCase);
    }
    onTestCaseStarted(testCaseStarted) {
        this.currentTestCaseId = testCaseStarted.testCaseId;
        this.storage.saveTestCaseStarted(testCaseStarted);
    }
    testStepStarted(testStepStarted) {
        this.storage.saveTestStepStarted(testStepStarted);
    }
    onTestStepFinished(testStepFinished) {
        this.storage.saveTestStepFinished(testStepFinished);
    }
    testCaseFinished(testCaseFinished) {
        this.currentTestCaseId = undefined;
        this.storage.saveTestCaseFinished(testCaseFinished);
    }
    onTestRunFinished(_testRunFinished) {
        const { configurationId } = this.client.getConfig();
        const results = this.storage.getTestRunResults(configurationId);
        if (this.testRunId !== undefined && results.length > 0) {
            Promise.all([
                this.testRunId,
                this.testRunStarted,
                Promise.all(this.attachmentsQueue),
            ])
                .then(async ([id]) => {
                const autotests = this.storage.getAutotests(this.client.getConfig().projectId);
                await Promise.all(autotests.map((autotestPost) => {
                    const result = results.find((result) => result.autotestExternalId === autotestPost.externalId);
                    if (result !== undefined) {
                        if (result.outcome !== 'Passed') {
                            return this.loadAutotest(autotestPost);
                        }
                        return this.loadPassedAutotest(autotestPost);
                    }
                }));
                await Promise.all(results.map((result) => {
                    return this.client.loadTestRunResults(id, [result]);
                }));
            })
                .catch((err) => {
                var _a;
                console.error(err);
                (_a = this.testRunId) === null || _a === void 0 ? void 0 : _a.then((id) => this.client.completeTestRun(id));
            });
        }
    }
    async loadAutotest(autotestPost) {
        var _a;
        try {
            await this.createNewAutotest(autotestPost);
        }
        catch (err) {
            const axiosError = err;
            if (((_a = axiosError.response) === null || _a === void 0 ? void 0 : _a.status) === 409) {
                const [autotest] = await this.client.getAutotest({
                    projectId: this.client.getConfig().projectId,
                    externalId: autotestPost.externalId,
                });
                await this.updateAutotest(Object.assign(Object.assign({}, autotest), { links: autotestPost.links }));
            }
            else {
                this.logError(axiosError);
            }
        }
    }
    async loadPassedAutotest(autotestPost) {
        var _a;
        try {
            await this.createNewAutotest(autotestPost);
        }
        catch (err) {
            const axiosError = err;
            if (((_a = axiosError.response) === null || _a === void 0 ? void 0 : _a.status) === 409) {
                await this.updateAutotest(autotestPost);
            }
            else {
                this.logError(axiosError);
            }
        }
        if (autotestPost.workItemId !== undefined) {
            this.linkWorkItem(autotestPost.externalId, autotestPost.workItemId);
        }
    }
    createTestRun() {
        const { projectId } = this.client.getConfig();
        this.testRunId = this.client
            .createTestRun({
            projectId,
        })
            .then((testRun) => testRun.id);
        this.testRunStarted = this.testRunId.then((id) => this.client.startTestRun(id));
    }
    async createNewAutotest(autotestPost) {
        await this.client.createAutotest(autotestPost);
    }
    async updateAutotest(autotestPost) {
        await this.client.updateAutotest(autotestPost).catch(this.logError);
    }
    async linkWorkItem(externalId, workItemId) {
        const [autotest] = await this.client
            .getAutotest({
            projectId: this.client.getConfig().projectId,
            externalId: externalId,
        })
            .catch(() => []);
        if ((autotest === null || autotest === void 0 ? void 0 : autotest.id) !== undefined) {
            await this.client.linkToWorkItem(autotest.id, {
                id: workItemId,
            });
        }
    }
    addMessage(message) {
        if (this.currentTestCaseId === undefined) {
            throw new Error('CurrentTestCaseId is not set');
        }
        this.storage.addMessage(this.currentTestCaseId, message);
    }
    addLinks(links) {
        if (this.currentTestCaseId === undefined) {
            throw new Error('CurrentTestCaseId is not set');
        }
        this.storage.addLinks(this.currentTestCaseId, links);
    }
    addAttachments(attachments) {
        if (this.currentTestCaseId === undefined) {
            throw new Error('CurrentTestCaseId is not set');
        }
        const currentTestCaseId = this.currentTestCaseId;
        this.attachmentsQueue.push(...attachments.map(async (attachment) => {
            const { id } = await this.client.loadAttachment(attachment);
            if (id === undefined) {
                // NOTE: Why?
                console.warn('Attachment id is not returned');
                return;
            }
            this.storage.addAttachment(currentTestCaseId, id);
        }));
    }
    logError(err) {
        var _a, _b;
        console.error((_a = err.response) === null || _a === void 0 ? void 0 : _a.status, err.config.method, err.config.url, (_b = err.response) === null || _b === void 0 ? void 0 : _b.data);
    }
}
exports.TestItFormatter = TestItFormatter;
//# sourceMappingURL=formatter.js.map